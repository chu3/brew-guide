# 状态持久化系统使用指南

这个文档介绍了我们的状态持久化系统，它可以在页面刷新或用户离开后保留用户的设置和选择。本系统适用于各种需要记住用户状态的场景，如筛选条件、视图模式、排序选项等。

## 目录

- [核心功能](#核心功能)
- [使用方法](#使用方法)
- [API参考](#api参考)
- [实际应用示例](#实际应用示例)
- [最佳实践](#最佳实践)

## 核心功能

- **跨会话持久化**：即使页面刷新或浏览器关闭后重新打开，用户的设置仍然保持
- **多数据类型支持**：支持字符串、数字、布尔值和复杂对象的存储
- **命名空间隔离**：不同功能模块的状态互不干扰
- **服务器端渲染兼容**：正确处理在SSR环境下localStorage不可用的情况
- **React Hook支持**：提供类似useState的使用体验

## 使用方法

### 基本使用

使用`usePersistedState` Hook，它的接口与React的`useState`非常相似：

```tsx
import { usePersistedState } from '@/lib/hooks/usePersistedState';

function MyComponent() {
  // 参数：模块名称，键名，默认值
  const [count, setCount] = usePersistedState('myModule', 'counter', 0);
  
  return (
    <div>
      <p>计数: {count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}
```

### 支持的数据类型

```tsx
// 字符串
const [text, setText] = usePersistedState('myModule', 'textInput', '');

// 数字
const [count, setCount] = usePersistedState('myModule', 'counter', 0);

// 布尔值
const [enabled, setEnabled] = usePersistedState('myModule', 'isEnabled', false);

// 复杂对象
const [user, setUser] = usePersistedState('myModule', 'userData', { 
  name: '', 
  preferences: {} 
});
```

### 状态更新

与`useState`一样，支持函数式更新：

```tsx
// 直接设置新值
setCount(10);

// 基于先前的值更新
setCount(prevCount => prevCount + 1);

// 更新对象的部分属性
setUser(prevUser => ({ ...prevUser, name: 'New Name' }));
```

## API参考

### usePersistedState

```tsx
function usePersistedState<T>(
  moduleName: string,   // 模块名称，用于隔离不同功能的状态
  key: string,          // 状态键名
  initialValue: T       // 初始值/默认值
): [T, (value: T | ((prevValue: T) => T)) => void]
```

### 底层API

如果你需要在非React环境中使用，也可以直接使用底层API：

```tsx
import { 
  getStringState, saveStringState,
  getBooleanState, saveBooleanState,
  getNumberState, saveNumberState,
  getObjectState, saveObjectState,
  clearState, clearModuleState
} from '@/lib/statePersistence';

// 保存状态
saveStringState('myModule', 'username', 'admin');

// 读取状态
const username = getStringState('myModule', 'username', ''); // 默认值为空字符串

// 清除特定状态
clearState('myModule', 'username');

// 清除整个模块的所有状态
clearModuleState('myModule');
```

## 实际应用示例

### 筛选选项持久化

```tsx
function FilterPanel() {
  const [sortOption, setSortOption] = usePersistedState('productList', 'sortBy', 'newest');
  const [filterCategory, setFilterCategory] = usePersistedState('productList', 'category', 'all');
  const [showOutOfStock, setShowOutOfStock] = usePersistedState('productList', 'outOfStock', false);
  
  // 组件逻辑...
}
```

### 表单状态持久化

```tsx
function MultiStepForm() {
  const [formData, setFormData] = usePersistedState('registration', 'formData', {
    step: 1,
    personalInfo: { name: '', email: '' },
    address: { city: '', zipCode: '' }
  });
  
  const updateFormField = (step, field, value) => {
    setFormData(prev => {
      if (step === 1) {
        return { ...prev, personalInfo: { ...prev.personalInfo, [field]: value } };
      } else {
        return { ...prev, address: { ...prev.address, [field]: value } };
      }
    });
  };
  
  // 表单逻辑...
}
```

### 用户界面偏好设置

```tsx
function AppSettings() {
  const [theme, setTheme] = usePersistedState('ui', 'theme', 'light');
  const [fontSize, setFontSize] = usePersistedState('ui', 'fontSize', 'medium');
  const [language, setLanguage] = usePersistedState('ui', 'language', 'zh-CN');
  
  // 设置界面逻辑...
}
```

## 最佳实践

1. **模块命名规范**：使用具有描述性的模块名称，如`coffee-beans`、`notes`、`ui-settings`等

2. **键名命名规范**：选择明确表达数据含义的键名，如`sortOption`、`selectedCategory`等

3. **合理分组**：相关的状态应该使用相同的模块名，便于管理和清理

4. **默认值设置**：始终提供合理的默认值，确保在首次使用或清除数据后应用程序能正常工作

5. **避免存储大型数据**：localStorage有容量限制，不适合存储大量数据。只保存必要的UI状态

6. **敏感数据处理**：不要存储敏感信息，如密码、令牌等。这些应该使用更安全的存储机制

7. **清理机制**：当功能发生重大变更时，考虑提供清理旧数据的机制：
   ```tsx
   // 版本更新时清理旧数据
   if (appVersion !== savedVersion) {
     clearModuleState('outdatedModule');
     saveStringState('app', 'version', appVersion);
   }
   ```

## 注意事项

- localStorage是同步API，大量读写可能影响性能
- 不同浏览器对localStorage的大小限制不同，通常为5MB左右
- 私密浏览模式可能会限制localStorage的使用 